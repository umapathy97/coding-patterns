// without negative numbers:
use two pointers:
left=0;
right=0;
while(right<n) {
sum+=A[right];
  while(sum{$based on condition}) {
  left++;
  max = Math.max(max,right-left+1)// for max sum > or < k
  }
  max = Math.max(max,right-left+1 // for max sum == k
}

time complexity:O(n+n) as each elements may be visited twice in worst case.

// with negative numbers:
create a hashmap.
put(0,-1) in map.
update sum at each iteration
for each sum put it in map.
// to find subarray with given sum
if we found any key which equals (sum-s) then the subarray will be from that index to i.

